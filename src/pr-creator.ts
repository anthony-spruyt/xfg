import { readFileSync, existsSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { RepoInfo } from "./repo-detector.js";
import {
  getPRStrategy,
  MergeResult,
  PRMergeConfig,
} from "./strategies/index.js";
import { interpolateXfgContent } from "./xfg-template.js";
import { CommandExecutor } from "./command-executor.js";

// Re-export for backwards compatibility and testing
export { escapeShellArg } from "./shell-utils.js";

export interface FileAction {
  fileName: string;
  action: "create" | "update" | "skip" | "delete";
}

export interface PROptions {
  repoInfo: RepoInfo;
  branchName: string;
  baseBranch: string;
  files: FileAction[];
  workDir: string;
  dryRun?: boolean;
  /** Number of retries for API operations (default: 3) */
  retries?: number;
  /** Custom PR body template */
  prTemplate?: string;
  /** Optional command executor for shell commands (for testing) */
  executor?: CommandExecutor;
}

export interface PRResult {
  url?: string;
  success: boolean;
  message: string;
}

function loadDefaultTemplate(): string {
  // Try to find PR.md in the project root
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  const templatePath = join(__dirname, "..", "PR.md");

  if (existsSync(templatePath)) {
    return readFileSync(templatePath, "utf-8");
  }

  // Fallback template
  return `## Summary

Automated sync of configuration files to \${xfg:repo.fullName}.

## Changes

\${xfg:pr.fileChanges}

## Source

Configuration synced using [xfg](https://github.com/anthony-spruyt/xfg).

---

_This PR was automatically generated by [xfg](https://github.com/anthony-spruyt/xfg)_`;
}

/**
 * Format file changes list, excluding skipped files
 */
function formatFileChanges(files: FileAction[]): string {
  const changedFiles = files.filter((f) => f.action !== "skip");
  return changedFiles
    .map((f) => {
      let actionText: string;
      switch (f.action) {
        case "create":
          actionText = "Created";
          break;
        case "update":
          actionText = "Updated";
          break;
        case "delete":
          actionText = "Deleted";
          break;
        default:
          actionText = "Changed";
      }
      return `- ${actionText} \`${f.fileName}\``;
    })
    .join("\n");
}

/**
 * Format PR body using template with ${xfg:...} variables.
 *
 * Available PR-specific variables:
 * - ${xfg:pr.fileChanges} - formatted list of changed files
 * - ${xfg:pr.fileCount} - number of changed files
 * - ${xfg:pr.title} - the PR title
 *
 * Plus all standard repo variables (repo.name, repo.owner, etc.)
 */
export function formatPRBody(
  files: FileAction[],
  repoInfo: RepoInfo,
  customTemplate?: string,
): string {
  const template = customTemplate ?? loadDefaultTemplate();
  const fileChanges = formatFileChanges(files);
  const changedFiles = files.filter((f) => f.action !== "skip");
  const title = formatPRTitle(files);

  // Create context with PR-specific variables
  const result = interpolateXfgContent(template, {
    repoInfo,
    fileName: "PR.md",
    vars: {
      "pr.fileChanges": fileChanges,
      "pr.fileCount": String(changedFiles.length),
      "pr.title": title,
    },
  });

  return result as string;
}

/**
 * Generate PR title based on files changed (excludes skipped files)
 */
export function formatPRTitle(files: FileAction[]): string {
  const changedFiles = files.filter((f) => f.action !== "skip");

  if (changedFiles.length === 1) {
    return `chore: sync ${changedFiles[0].fileName}`;
  }

  if (changedFiles.length <= 3) {
    const fileNames = changedFiles.map((f) => f.fileName).join(", ");
    return `chore: sync ${fileNames}`;
  }

  return `chore: sync ${changedFiles.length} config files`;
}

export async function createPR(options: PROptions): Promise<PRResult> {
  const {
    repoInfo,
    branchName,
    baseBranch,
    files,
    workDir,
    dryRun,
    retries,
    prTemplate,
    executor,
  } = options;

  const title = formatPRTitle(files);
  const body = formatPRBody(files, repoInfo, prTemplate);

  if (dryRun) {
    return {
      success: true,
      message: `[DRY RUN] Would create PR: "${title}"`,
    };
  }

  // Get the appropriate strategy and execute
  const strategy = getPRStrategy(repoInfo, executor);
  return strategy.execute({
    repoInfo,
    title,
    body,
    branchName,
    baseBranch,
    workDir,
    retries,
  });
}

export interface MergePROptions {
  repoInfo: RepoInfo;
  prUrl: string;
  mergeConfig: PRMergeConfig;
  workDir: string;
  dryRun?: boolean;
  retries?: number;
  /** Optional command executor for shell commands (for testing) */
  executor?: CommandExecutor;
}

export async function mergePR(options: MergePROptions): Promise<MergeResult> {
  const { repoInfo, prUrl, mergeConfig, workDir, dryRun, retries, executor } =
    options;

  if (dryRun) {
    const modeText =
      mergeConfig.mode === "force"
        ? "force merge"
        : mergeConfig.mode === "auto"
          ? "enable auto-merge"
          : "leave open for manual review";
    return {
      success: true,
      message: `[DRY RUN] Would ${modeText}`,
      merged: false,
    };
  }

  // Get the appropriate strategy and execute merge
  const strategy = getPRStrategy(repoInfo, executor);
  return strategy.merge({
    prUrl,
    config: mergeConfig,
    workDir,
    retries,
  });
}
