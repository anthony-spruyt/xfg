import { readFileSync, existsSync } from "node:fs";
import { join, dirname } from "node:path";
import { fileURLToPath } from "node:url";
import { RepoInfo } from "./repo-detector.js";
import {
  getPRStrategy,
  MergeResult,
  PRMergeConfig,
} from "./strategies/index.js";

// Re-export for backwards compatibility and testing
export { escapeShellArg } from "./shell-utils.js";

export interface FileAction {
  fileName: string;
  action: "create" | "update" | "skip";
}

export interface PROptions {
  repoInfo: RepoInfo;
  branchName: string;
  baseBranch: string;
  files: FileAction[];
  workDir: string;
  dryRun?: boolean;
  /** Number of retries for API operations (default: 3) */
  retries?: number;
  /** Custom PR body template */
  prTemplate?: string;
}

export interface PRResult {
  url?: string;
  success: boolean;
  message: string;
}

function loadDefaultTemplate(): string {
  // Try to find PR.md in the project root
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  const templatePath = join(__dirname, "..", "PR.md");

  if (existsSync(templatePath)) {
    return readFileSync(templatePath, "utf-8");
  }

  // Fallback template
  return `## Summary

Automated sync of configuration files.

## Changes

{{FILE_CHANGES}}

## Source

Configuration synced using [xfg](https://github.com/anthony-spruyt/xfg).

---

_This PR was automatically generated by [xfg](https://github.com/anthony-spruyt/xfg)_`;
}

/**
 * Format file changes list, excluding skipped files
 */
function formatFileChanges(files: FileAction[]): string {
  const changedFiles = files.filter((f) => f.action !== "skip");
  return changedFiles
    .map((f) => {
      const actionText = f.action === "create" ? "Created" : "Updated";
      return `- ${actionText} \`${f.fileName}\``;
    })
    .join("\n");
}

/**
 * Format PR body using template with {{FILE_CHANGES}} placeholder
 */
export function formatPRBody(
  files: FileAction[],
  customTemplate?: string,
): string {
  const template = customTemplate ?? loadDefaultTemplate();
  const fileChanges = formatFileChanges(files);

  return template.replace(/\{\{FILE_CHANGES\}\}/g, fileChanges);
}

/**
 * Generate PR title based on files changed (excludes skipped files)
 */
export function formatPRTitle(files: FileAction[]): string {
  const changedFiles = files.filter((f) => f.action !== "skip");

  if (changedFiles.length === 1) {
    return `chore: sync ${changedFiles[0].fileName}`;
  }

  if (changedFiles.length <= 3) {
    const fileNames = changedFiles.map((f) => f.fileName).join(", ");
    return `chore: sync ${fileNames}`;
  }

  return `chore: sync ${changedFiles.length} config files`;
}

export async function createPR(options: PROptions): Promise<PRResult> {
  const {
    repoInfo,
    branchName,
    baseBranch,
    files,
    workDir,
    dryRun,
    retries,
    prTemplate,
  } = options;

  const title = formatPRTitle(files);
  const body = formatPRBody(files, prTemplate);

  if (dryRun) {
    return {
      success: true,
      message: `[DRY RUN] Would create PR: "${title}"`,
    };
  }

  // Get the appropriate strategy and execute
  const strategy = getPRStrategy(repoInfo);
  return strategy.execute({
    repoInfo,
    title,
    body,
    branchName,
    baseBranch,
    workDir,
    retries,
  });
}

export interface MergePROptions {
  repoInfo: RepoInfo;
  prUrl: string;
  mergeConfig: PRMergeConfig;
  workDir: string;
  dryRun?: boolean;
  retries?: number;
}

export async function mergePR(options: MergePROptions): Promise<MergeResult> {
  const { repoInfo, prUrl, mergeConfig, workDir, dryRun, retries } = options;

  if (dryRun) {
    const modeText =
      mergeConfig.mode === "force"
        ? "force merge"
        : mergeConfig.mode === "auto"
          ? "enable auto-merge"
          : "leave open for manual review";
    return {
      success: true,
      message: `[DRY RUN] Would ${modeText}`,
      merged: false,
    };
  }

  // Get the appropriate strategy and execute merge
  const strategy = getPRStrategy(repoInfo);
  return strategy.merge({
    prUrl,
    config: mergeConfig,
    workDir,
    retries,
  });
}
